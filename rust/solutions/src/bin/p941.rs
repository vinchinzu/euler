// Problem 941 - de Bruijn's Combination Lock
//
// Compute F(10^7) mod 1234567891 where F(N) = sum of p_n * a_n,
// with a_n generated by an LCG and p_n being the rank when sorted
// by position in the lexicographically smallest de Bruijn sequence C(10,12).

const K: usize = 10; // alphabet size (digits 0-9, mapped to symbols 1..10)
const N: usize = 12; // word length
const MOD_LCG: u64 = 1_000_000_000_000; // 10^12
const LCG_MUL: u64 = 920461;
const LCG_ADD: u64 = 800217387569;
const MOD_ANS: u64 = 1234567891;

/// Precomputed powers: POWER[i] = K^i (as i64 for the ranking math).
fn make_powers() -> [i64; N + 1] {
    let mut p = [1i64; N + 1];
    for i in 1..=N {
        p[i] = p[i - 1] * K as i64;
    }
    p
}

/// Compute the Lyndon prefix length of w[1..N].
/// w uses 1-based indexing; symbols are in 1..=K.
#[inline]
fn lyn(w: &[i32; N + 1]) -> usize {
    let mut p = 1usize;
    for i in 2..=N {
        let wi = w[i];
        let wip = w[i - p];
        if wi < wip {
            return p;
        }
        if wi > wip {
            p = i;
        }
    }
    p
}

/// Check if w[1..N] is a necklace (lexicographically smallest rotation).
#[inline]
fn is_necklace(w: &[i32; N + 1]) -> bool {
    let mut p = 1usize;
    for i in 2..=N {
        let wi = w[i];
        let wip = w[i - p];
        if wi < wip {
            return false;
        }
        if wi > wip {
            p = i;
        }
    }
    (N % p) == 0
}

/// Compute the largest necklace <= w, storing in out.
fn largest_necklace(w: &[i32; N + 1], out: &mut [i32; N + 1]) {
    for i in 1..=N {
        out[i] = w[i];
    }
    while !is_necklace(out) {
        let p = lyn(out);
        out[p] -= 1;
        for i in (p + 1)..=N {
            out[i] = K as i32;
        }
    }
}

/// Scratch buffers for the T function and rank_db.
struct RankScratch {
    power: [i64; N + 1],
    neck_rep: [i32; N + 1],
    prev: [i32; N + 1],
    t_neck: [i32; N + 1],
    b: [[i64; N + 1]; N + 1],
    suf: [[usize; N + 1]; N + 1],
}

impl RankScratch {
    fn new() -> Self {
        Self {
            power: make_powers(),
            neck_rep: [0i32; N + 1],
            prev: [0i32; N + 1],
            t_neck: [0i32; N + 1],
            b: [[0i64; N + 1]; N + 1],
            suf: [[0usize; N + 1]; N + 1],
        }
    }

    /// T(w): number of necklaces with content <= w.
    fn t_func(&mut self, w: &[i32; N + 1]) -> i64 {
        largest_necklace(w, &mut self.t_neck);

        // Compute B[t][j]
        self.b[0][0] = 1;
        for t in 1..=N {
            self.b[t][t] = 0;
            for j in (0..t).rev() {
                self.b[t][j] = self.b[t][j + 1]
                    + (K as i64 - self.t_neck[j + 1] as i64) * self.b[t - j - 1][0];
            }
        }

        // Compute suf[i][j] for i >= 2
        for i in 2..=N {
            let mut s = i;
            for j in i..=N {
                if self.t_neck[j] > self.t_neck[j - s + 1] {
                    s = j + 1;
                }
                self.suf[i][j] = j - s + 1;
            }
        }

        let mut tot = lyn(&self.t_neck) as i64;
        for t in 1..=N {
            let b0 = self.b[t - 1][0];
            for j in 0..N {
                if j + t <= N {
                    tot += b0 * (self.t_neck[j + 1] as i64 - 1) * self.power[N - t - j];
                } else {
                    let sfx = if j < N - t + 2 {
                        0
                    } else {
                        self.suf[N - t + 2][j]
                    };
                    if self.t_neck[j + 1] as i64 > self.t_neck[sfx + 1] as i64 {
                        tot += self.b[N - j + sfx][sfx + 1]
                            + (self.t_neck[j + 1] as i64 - self.t_neck[sfx + 1] as i64 - 1)
                                * self.b[N - j - 1][0];
                    }
                }
            }
        }

        tot
    }

    /// Rank a word w[1..N] in the de Bruijn sequence. Returns 1-based position.
    fn rank_db(&mut self, w: &[i32; N + 1]) -> i64 {
        // Special case: w = K^t 1^(N-t) for t >= 1 (wraparound substrings)
        let mut t = 0usize;
        while t < N && w[t + 1] == K as i32 {
            t += 1;
        }
        let mut j = t;
        while j < N && w[j + 1] == 1 {
            j += 1;
        }
        if t >= 1 && j == N {
            return self.power[N] - t as i64 + 1;
        }

        // If w is already a necklace
        if is_necklace(w) {
            let l = lyn(w) as i64;
            // Need a copy for t_func since it uses self.t_neck
            let mut w_copy = [0i32; N + 1];
            w_copy.copy_from_slice(w);
            return 1 - l + self.t_func(&w_copy);
        }

        // Find the necklace representative and rotation offset s
        for i in 1..=N {
            self.neck_rep[i] = w[i];
        }
        let mut s = 0usize;
        while !is_necklace(&self.neck_rep) {
            s += 1;
            for i in 1..=N {
                let j2 = i + s;
                self.neck_rep[i] = if j2 <= N { w[j2] } else { w[j2 - N] };
            }
        }

        // Copy neck_rep for recursive call
        let mut nr = [0i32; N + 1];
        nr.copy_from_slice(&self.neck_rep);

        if s != t {
            let l = lyn(&nr) as i64;
            return self.rank_db(&nr) + l - s as i64;
        }
        if lyn(&nr) < N {
            return self.rank_db(&nr) - s as i64;
        }

        // Adjust suffix to 1s, move to previous necklace
        for i in (N - s + 1)..=N {
            nr[i] = 1;
        }
        largest_necklace(&nr, &mut self.prev);
        let mut prev_copy = [0i32; N + 1];
        prev_copy.copy_from_slice(&self.prev);
        let l = lyn(&prev_copy) as i64;
        self.rank_db(&prev_copy) + l - s as i64
    }
}

/// Convert a 12-digit number to 1-based symbols in w[1..12].
#[inline]
fn int_to_word12(x: u64, w: &mut [i32; N + 1]) {
    let hi = (x / 100_000_000) as u32;
    let mid = ((x / 10_000) % 10_000) as u32;
    let lo = (x % 10_000) as u32;

    // hi: 4 digits
    w[1] = (hi / 1000) as i32 + 1;
    w[2] = ((hi / 100) % 10) as i32 + 1;
    w[3] = ((hi / 10) % 10) as i32 + 1;
    w[4] = (hi % 10) as i32 + 1;

    // mid: 4 digits
    w[5] = (mid / 1000) as i32 + 1;
    w[6] = ((mid / 100) % 10) as i32 + 1;
    w[7] = ((mid / 10) % 10) as i32 + 1;
    w[8] = (mid % 10) as i32 + 1;

    // lo: 4 digits
    w[9] = (lo / 1000) as i32 + 1;
    w[10] = ((lo / 100) % 10) as i32 + 1;
    w[11] = ((lo / 10) % 10) as i32 + 1;
    w[12] = (lo % 10) as i32 + 1;
}

/// LSD radix sort of (keys, vals) by keys. 3 passes with 16-bit radix.
fn radix_sort(keys: &mut Vec<u64>, vals: &mut Vec<u64>) {
    let n = keys.len();
    if n <= 1 {
        return;
    }
    let bits_per_pass: u32 = 16;
    let radix = 1usize << bits_per_pass;
    let mask = (radix - 1) as u64;

    let mut tmp_keys = vec![0u64; n];
    let mut tmp_vals = vec![0u64; n];

    for pass in 0..3u32 {
        let shift = pass * bits_per_pass;
        let mut counts = vec![0usize; radix];

        let (src_k, src_v, dst_k, dst_v) = if pass % 2 == 0 {
            (
                keys as &Vec<u64>,
                vals as &Vec<u64>,
                &mut tmp_keys,
                &mut tmp_vals,
            )
        } else {
            (
                &tmp_keys as &Vec<u64>,
                &tmp_vals as &Vec<u64>,
                keys as &mut Vec<u64>,
                vals as &mut Vec<u64>,
            )
        };

        for i in 0..n {
            counts[((src_k[i] >> shift) & mask) as usize] += 1;
        }

        let mut total = 0usize;
        for b in 0..radix {
            let c = counts[b];
            counts[b] = total;
            total += c;
        }

        for i in 0..n {
            let x = src_k[i];
            let b = ((x >> shift) & mask) as usize;
            let p = counts[b];
            dst_k[p] = x;
            dst_v[p] = src_v[i];
            counts[b] = p + 1;
        }
    }

    // After 3 passes (odd), sorted data is in tmp_keys/tmp_vals
    // Copy back
    keys.copy_from_slice(&tmp_keys);
    vals.copy_from_slice(&tmp_vals);
}

fn main() {
    let big_n: usize = 10_000_000;

    let mut scratch = RankScratch::new();
    let mut w = [0i32; N + 1];

    let mut a_vals = Vec::with_capacity(big_n);
    let mut ranks = Vec::with_capacity(big_n);

    // Generate LCG values and compute ranks
    let mut a: u64 = 0;
    for _ in 0..big_n {
        a = (LCG_MUL.wrapping_mul(a).wrapping_add(LCG_ADD)) % MOD_LCG;
        int_to_word12(a, &mut w);
        let rank = scratch.rank_db(&w);
        a_vals.push(a);
        ranks.push(rank as u64);
    }

    // Sort by rank
    radix_sort(&mut ranks, &mut a_vals);

    // Compute F(N) mod MOD_ANS
    let mut acc: u64 = 0;
    for i in 0..big_n {
        let p = (i as u64 + 1) % MOD_ANS;
        let val = a_vals[i] % MOD_ANS;
        acc = (acc + p * val % MOD_ANS) % MOD_ANS;
    }

    println!("{}", acc);
}
