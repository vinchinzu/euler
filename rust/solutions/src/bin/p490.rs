// Project Euler 490: Jumping frog
// Matrix exponentiation on 121x121 transition matrix.

const DIM: usize = 121;
const MOD: i64 = 1_000_000_000;

type Mat = [[i64; DIM]; DIM];

#[inline(never)]
fn mat_mul(a: &Mat, b: &Mat, c: &mut Mat) {
    // Use i128 accumulator rows to defer mod reduction
    let mut acc = [0i128; DIM];
    for i in 0..DIM {
        // Zero accumulator
        for j in 0..DIM { acc[j] = 0; }
        for k in 0..DIM {
            if a[i][k] == 0 { continue; }
            let aik = a[i][k] as i128;
            for j in 0..DIM {
                acc[j] += aik * b[k][j] as i128;
            }
            // Reduce periodically to prevent overflow
            // max value after 121 iterations: 121 * (10^9)^2 = 1.21e20, fits i128
            // But reduce every 16 to keep values smaller for faster multiply
            if k % 16 == 15 {
                for j in 0..DIM { acc[j] %= MOD as i128; }
            }
        }
        for j in 0..DIM {
            c[i][j] = (acc[j] % MOD as i128) as i64;
        }
    }
}

fn mat_vec(a: &Mat, v: &[i64; DIM]) -> [i64; DIM] {
    let mut out = [0i64; DIM];
    for i in 0..DIM {
        let mut s: i128 = 0;
        for j in 0..DIM {
            s += a[i][j] as i128 * v[j] as i128;
            if j % 16 == 15 { s %= MOD as i128; }
        }
        out[i] = (s % MOD as i128) as i64;
    }
    out
}

fn mat_pow(a: &Mat, mut e: i64) -> Box<Mat> {
    let mut result: Box<Mat> = Box::new([[0i64; DIM]; DIM]);
    for i in 0..DIM { result[i][i] = 1; }
    let mut base: Box<Mat> = Box::new(*a);
    let mut tmp: Box<Mat> = Box::new([[0i64; DIM]; DIM]);
    while e > 0 {
        if e & 1 == 1 {
            mat_mul(&result, &base, &mut tmp);
            std::mem::swap(&mut result, &mut tmp);
        }
        mat_mul(&base, &base, &mut tmp);
        std::mem::swap(&mut base, &mut tmp);
        e >>= 1;
    }
    result
}

fn main() {
    let coeffs: [i64; 120] = [6, 9, 119, 776, 2928, 999999859, 999947224, 999685922,
        999532226, 1006034, 3403103, 3091675, 18854028, 41939739, 994839428,
        123907888, 686578570, 538510631, 463875565, 593907319, 775112607,
        862799442, 826799722, 323568068, 272946171, 865736624, 849803095,
        311419118, 805102114, 339105472, 456964300, 305937016, 337515567,
        230568131, 989586447, 512038563, 610224796, 175130668, 153437041,
        542540920, 50625753, 340116729, 88372743, 907746334, 593763395,
        370623486, 270466732, 598807528, 985040772, 299982216, 940789720,
        619684566, 241159230, 555403477, 447351797, 516881602, 369898831,
        728139066, 653295692, 399706398, 677312837, 974991247, 434754226,
        941011599, 119818263, 453982603, 899907409, 501223070, 213814420,
        937503575, 348572247, 422813235, 912044703, 988284254, 627070716,
        197746192, 763985855, 402499115, 193039987, 116884499, 386287404,
        506735768, 560044596, 134890008, 826753664, 554299492, 726711998,
        124504874, 979617447, 769179585, 964951155, 201335039, 391976502,
        964735427, 16230901, 520533199, 281250193, 800363863, 100229687,
        972206742, 12790510, 994869589, 1367679, 999105321, 1188015,
        999184849, 110016, 999999166, 3761, 162, 1064, 999998439, 2081,
        999999722, 7, 6, 999999999, 999999998, 0, 999999999];

    let state_init: [i64; 121] = [108475375, 199896031, 931687936, 702009464, 714606784,
        266999125, 155539000, 420988719, 720702269, 433917201, 103102296,
        841260071, 148478597, 673860672, 275943000, 145433664, 517075976,
        796818392, 659506375, 581452328, 133701347, 220769000, 533832875,
        158625000, 163559688, 49094879, 173342528, 133133824, 279836979,
        301229176, 639670651, 737905891, 344982296, 218953000, 996223521,
        995491576, 128395544, 610594424, 82826952, 616671875, 831294792,
        337037632, 879337000, 324556983, 732813625, 284586816, 640748631,
        730263624, 15337869, 261630737, 824684707, 225590449, 478279633,
        815873909, 93712153, 175142936, 850923968, 360327168, 409331263,
        506745561, 516656879, 749053847, 106505728, 969129472, 614533621,
        553166237, 795894829, 563408152, 252528683, 759473000, 149105816,
        249057352, 122210271, 671427736, 357983592, 592954569, 608818931,
        579422939, 772966179, 113444875, 36210176, 650033625, 218515456,
        341269843, 465287488, 873529125, 659090427, 6592000, 414158769,
        294164427, 845019456, 99129291, 833571136, 91407928, 983217139,
        481670875, 642957656, 805769125, 284731347, 817479875, 897713875,
        840788536, 172441623, 912144001, 95811431, 141267272, 632545224,
        841287201, 481544000, 158340421, 16387064, 1643032, 175616, 21952,
        2744, 216, 8, 1, 1, 1, 828475848];

    // Build transition matrix
    let mut t: Box<Mat> = Box::new([[0i64; DIM]; DIM]);

    for j in 0..120 {
        t[0][j] = coeffs[j];
    }
    for i in 1..120 {
        t[i][i - 1] = 1;
    }
    for j in 0..120 {
        t[120][j] = coeffs[j];
    }
    t[120][120] = 1;

    let target: i64 = 100_000_000_000_000;
    let steps = target - 120;

    let tp = mat_pow(&t, steps);

    let result = mat_vec(&tp, &state_init);

    println!("{}", result[120]);
}
