# Consider all integer combinations of ab for 2  a  5 and 2  b  5:

# 22=4, 23=8, 24=16, 25=32
# 32=9, 33=27, 34=81, 35=243
# 42=16, 43=64, 44=256, 45=1024
# 52=25, 53=125, 54=625, 55=3125
# If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

# How many distinct terms are in the sequence generated by ab for 2  a  100 and 2  b  100?
require 'benchmark'
require 'set' # Using the Set data structure for efficient storage of unique terms.

def powers(n)
  # Define ranges for a and b from 2 to n, inclusive.
  # Iterating over ranges directly is memory-efficient compared to creating intermediate arrays.
  a_range = (2..n) 
  b_range = (2..n)
  
  # Use a Set to store the generated terms.
  # A Set automatically ensures that all its elements are unique,
  # which is more efficient than collecting all terms in an array and then calling .uniq.
  distinct_terms = Set.new 

  a_range.each do |x|
    b_range.each do |y|
      # Calculate a^b and add it to the set.
      # If the term already exists in the set, .add operation does nothing, thus handling duplicates.
      distinct_terms.add(x**y) 
    end
  end
 
  # The .size (or .count) of the set gives the number of distinct terms.
  distinct_terms.size 
end
 
 
 Benchmark.bm do |x|
 x.report("Solution: ") {
 puts  powers(100)

 }
 end
 
 
 