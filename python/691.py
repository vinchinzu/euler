"""Project Euler Problem 691: Longest Substring.

Given a binary string S = c_n generated by a_0 = 0, a_{2n}=a_n,
a_{2n+1}=1-a_n, b_n=⌊(n+1)/ϕ⌋-⌊n/ϕ⌋, and c_n=a_n+b_n-2(a_n)(b_n), find
Σ_k L(k,S) where L(k) is the length of the largest substring that appears at
least k times in S.

If we compute the suffix array for S and the LCP array of largest common
prefixes between alphabetically adjacent suffixes, then L(k) is the largest value
such that a contiguous range of k entries of the LCP array are all at least
that value. So we can iterate over the LCP values from largest to smallest,
keeping track of the current maximum contiguous range using a segment tree (that
directly indexes values into an array, resulting in constant time queries). If
the length of this range ever increases, then L(k) for all k up to the new
length can be set to the current LCP value.
"""

from __future__ import annotations

import math


def suffix_array(chars: list[int]) -> list[int]:
    """Build suffix array."""
    n = len(chars)
    sa = sorted(range(n), key=lambda i: chars[i:])
    classes = chars[:]
    
    length = 1
    while length < n:
        c = classes[:]
        new_classes = [0] * n
        class_num = 0
        for i in range(n):
            if i > 0 and (
                c[sa[i - 1]] != c[sa[i]]
                or sa[i - 1] + length >= n
                or c[sa[i - 1] + length // 2] != c[sa[i] + length // 2]
            ):
                class_num += 1
            new_classes[sa[i]] = class_num
        classes = new_classes
        
        cnt = list(range(n))
        sa_copy = sa[:]
        for i in range(n):
            s1 = sa_copy[i] - length
            if s1 >= 0:
                sa[cnt[classes[s1]]] = s1
                cnt[classes[s1]] += 1
        
        length *= 2
    
    return sa


def lcp(sa: list[int], chars: list[int]) -> list[int]:
    """Build LCP array."""
    n = len(sa)
    inv = [0] * n
    for i in range(n):
        inv[sa[i]] = i
    
    lcp_arr = [0] * (n - 1)
    h = 0
    for i in range(n):
        if inv[i] < n - 1:
            j = sa[inv[i] + 1]
            while (
                max(i, j) + h < len(chars)
                and chars[i + h] == chars[j + h]
            ):
                h += 1
            lcp_arr[inv[i]] = h
            if h > 0:
                h -= 1
    
    return lcp_arr


def solve() -> int:
    """Solve Problem 691."""
    N = 5000000
    PHI = (1 + math.sqrt(5)) / 2

    # Generate a array
    a = [0] * (N + 1)
    for n in range(1, N + 1):
        if n % 2 == 0:
            a[n] = a[n // 2]
        else:
            a[n] = 1 - a[n // 2]

    # Generate b array
    b = [0] * N
    for n in range(N):
        b[n] = int((n + 1) / PHI) - int(n / PHI)

    # Generate c array
    c = [0] * N
    for n in range(N):
        c[n] = a[n] + b[n] - 2 * a[n] * b[n]

    # Build suffix array and LCP
    sa = suffix_array(c)
    lcp_arr = lcp(sa, c)

    # Sort indices by LCP value (descending)
    order = sorted(range(N - 1), key=lambda i: -lcp_arr[i])

    ends = [-1] * (N - 1)
    L = [0] * (N + 1)
    L[1] = N
    max_freq = 1

    for i in order:
        left = i if (i == 0 or ends[i - 1] == -1) else ends[i - 1]
        right = (
            i if (i == N - 2 or ends[i + 1] == -1) else ends[i + 1]
        )
        ends[left] = right
        ends[right] = left
        freq = right - left + 2
        if freq > max_freq:
            for j in range(max_freq + 1, freq + 1):
                L[j] = lcp_arr[i]
            max_freq = freq

    ans = sum(L)
    return ans


def main() -> int:
    """Main entry point."""
    result = solve()
    print(result)
    return result


if __name__ == "__main__":
    main()
