#!/usr/bin/env python3
"""Project Euler 979: Hyperbolic frog on the {7,3} heptagon tiling.

We work on the adjacency graph of heptagons (each tile has 7 neighbors;
three tiles meet at each vertex). Let F(n) be the number of length-n
walks starting and ending at the same tile.

Key observation:
A length-n closed walk cannot reach graph distance > floor(n/2) from the
start, because each step changes the distance by at most 1. Therefore,
for n=20 we only need the finite ball of radius 10.

Combinatorial model (layers):
Layer k is the cycle of tiles at distance k from the start.
Each tile in layer k>=1 is of one of two types:
  * Type I  : exactly 1 neighbor in layer k-1
  * Type II : exactly 2 neighbors in layer k-1

The types along layer k form a cyclic word W_k over {I,II} generated by
this substitution (applied cyclically):
  I  -> I I II
  II -> I II

Moreover, the last symbol (II) in each substituted block represents the
boundary vertex between a tile and its clockwise successor, which gives
an explicit parent mapping from layer k to layer k-1.

Using this, we build the induced subgraph on layers 0..floor(n/2) and do
simple DP for walk counts.

No external libraries are used.
"""

from __future__ import annotations

import sys
from typing import List, Tuple


# Type encoding: 0 = I, 1 = II
_SUBS: Tuple[Tuple[int, ...], Tuple[int, ...]] = (
    (0, 0, 1),  # I  -> I I II
    (0, 1),  # II -> I II
)


def _build_layers(
    max_layer: int,
) -> Tuple[List[List[int]], List[List[int]], List[List[int]]]:
    """Build type words W_k and parent maps for layers 0..max_layer.

    Returns:
        types[k]   : list of type codes for layer k (layer 0 is [0])
        parent1[k] : for k>=1, parent index in layer k-1 (size = len(types[k]))
        parent2[k] : second parent index (or -1) for k>=1
    """
    types: List[List[int]] = [[] for _ in range(max_layer + 1)]
    parent1: List[List[int]] = [[] for _ in range(max_layer + 1)]
    parent2: List[List[int]] = [[] for _ in range(max_layer + 1)]

    # Layer 0: the starting tile (type label irrelevant here)
    types[0] = [0]

    if max_layer == 0:
        return types, parent1, parent2

    # Layer 1: 7 type-I tiles around the center
    types[1] = [0] * 7
    parent1[1] = [0] * 7
    parent2[1] = [-1] * 7

    for k in range(2, max_layer + 1):
        prev = types[k - 1]
        m = len(prev)

        cur: List[int] = []
        p1: List[int] = []
        p2: List[int] = []

        # Apply substitution block-by-block in cyclic order.
        for j, t in enumerate(prev):
            block = _SUBS[t]
            blen = len(block)
            for pos, ct in enumerate(block):
                cur.append(ct)
                p1.append(j)
                if pos == blen - 1:
                    # The trailing II corresponds to the boundary vertex between tile j and j+1.
                    p2.append((j + 1) % m)
                else:
                    p2.append(-1)

        types[k] = cur
        parent1[k] = p1
        parent2[k] = p2

    return types, parent1, parent2


def _build_ball_adjacency(max_layer: int) -> Tuple[List[List[int]], int, List[int]]:
    """Build adjacency list for the induced subgraph on layers 0..max_layer."""
    types, parent1, parent2 = _build_layers(max_layer)

    sizes = [len(types[k]) for k in range(max_layer + 1)]
    offsets = [0] * (max_layer + 1)
    total = 0
    for k in range(max_layer + 1):
        offsets[k] = total
        total += sizes[k]

    adj: List[List[int]] = [[] for _ in range(total)]

    def add_edge(u: int, v: int) -> None:
        adj[u].append(v)
        adj[v].append(u)

    origin = offsets[0]

    # Within-layer cycle edges for layers >= 1
    for k in range(1, max_layer + 1):
        off = offsets[k]
        m = sizes[k]
        for i in range(m):
            add_edge(off + i, off + ((i + 1) % m))

    # Between-layer edges from parent mappings
    # Layer 1 connects to origin.
    if max_layer >= 1:
        off1 = offsets[1]
        for i in range(sizes[1]):
            add_edge(origin, off1 + i)

    for k in range(2, max_layer + 1):
        off = offsets[k]
        poff = offsets[k - 1]
        for i in range(sizes[k]):
            add_edge(off + i, poff + parent1[k][i])
            p = parent2[k][i]
            if p != -1:
                add_edge(off + i, poff + p)

    # Sanity: all non-boundary nodes should have degree 7.
    # Boundary layer nodes have missing outward edges (outside the ball).
    if max_layer >= 1:
        for k in range(0, max_layer):
            off = offsets[k]
            for i in range(sizes[k]):
                u = off + i
                assert len(adj[u]) == 7, (k, i, len(adj[u]))

    return adj, origin, offsets


def F(n: int) -> int:
    """Number of length-n closed walks starting and ending at the start tile."""
    if n < 0:
        return 0
    if n == 0:
        return 1

    max_layer = n // 2
    adj, origin, _ = _build_ball_adjacency(max_layer)

    N = len(adj)
    dp = [0] * N
    dp[origin] = 1

    for _ in range(n):
        ndp = [0] * N
        for u, val in enumerate(dp):
            if val:
                for v in adj[u]:
                    ndp[v] += val
        dp = ndp

    return dp[origin]


def main() -> None:
    # Assert the given test value.
    assert F(4) == 119

    # Problem asks for F(20).
    print(F(20))


if __name__ == "__main__":
    main()
