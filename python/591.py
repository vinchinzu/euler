"""Project Euler Problem 591: Best approximation to π.

For a non-square value d, let I_d be the integer part of the closest
quadratic integer a+b√d approximation to π with parameters not exceeding
N. Find sum |I_d| for all non-square d less than K.

For a given d, the problem is equivalent to finding the closest lattice
point to (π, 0), in a lattice generated by u = (√d, 0) and v = (1, 1).
We use the Euclidean Algorithm to reduce the basis.
"""

from __future__ import annotations

from decimal import Decimal, getcontext
from math import isqrt

getcontext().prec = 50


def is_square(n: int) -> bool:
    """Check if n is a perfect square."""
    if n < 0:
        return False
    root = isqrt(n)
    return root * root == n


class Vector:
    """Represents a vector in the lattice."""

    def __init__(self, x: Decimal, ai: int, bi: int) -> None:
        """Initialize vector."""
        self.x = x
        self.ai = ai
        self.bi = bi


def solve() -> int:
    """Solve Problem 591."""
    N = 10**13
    K = 100
    PI = Decimal("3.141592653589793238462643383279")
    D = 5

    ans = 0

    for d in range(2, K):
        if is_square(d):
            continue

        sqrt_d = Decimal(d).sqrt()
        u = Vector(sqrt_d, 1, 0)
        v = Vector(Decimal(1), 1, 0)

        I = -1
        min_error = Decimal(1)

        while abs(u.ai) <= N:
            q = int((u.x / v.x).to_integral_value())
            r = Vector(
                u.x - Decimal(q) * v.x,
                u.ai - q * v.ai,
                u.bi - q * v.bi,
            )
            u, v = v, r

            det = float(u.x * Decimal(v.ai) - v.x * Decimal(u.ai))
            if abs(det) < 1e-10:
                break

            ui0 = int(float(PI * Decimal(v.ai) / Decimal(det)))
            vi0 = -int(float(PI * Decimal(u.ai) / Decimal(det)))

            for ui in range(ui0 - D, ui0 + D + 1):
                for vi in range(vi0 - D, vi0 + D + 1):
                    a = ui * u.ai + vi * v.ai
                    b = ui * u.bi + vi * v.bi
                    error = abs(Decimal(a) + Decimal(b) * sqrt_d - PI)
                    if abs(a) <= N and error < min_error:
                        I = a
                        min_error = error

        ans += abs(I)

    return ans


def main() -> int:
    """Main entry point."""
    result = solve()
    print(result)
    return result


if __name__ == "__main__":
    main()
