#!/usr/bin/env python

# Generated by GPT-5.2 Thinking web UI on 2025-12-22.

import math


# ---------- Helpers: primes ----------
def primes_up_to(n: int) -> list[int]:
    sieve = bytearray(b"\x01") * (n + 1)
    if n >= 0:
        sieve[0:2] = b"\x00\x00"
    r = int(n**0.5)
    for p in range(2, r + 1):
        if sieve[p]:
            step = p
            start = p * p
            sieve[start : n + 1 : step] = b"\x00" * (((n - start) // step) + 1)
    return [i for i in range(n + 1) if sieve[i]]


# ---------- Core math: H_{a,b} on the critical grid ----------
def _critical_z_values(a: int, b: int) -> list[float]:
    """
    Build the sorted list of critical x-values (including 0 and 1) for H_{a,b},
    BUT return only the corresponding z-values H_{a,b}(x) in that x-order.

    For odd coprime a,b:
      H'_{a,b}(x)=0  <=>  sin(aπx)+sin(bπx)=0
                    <=>  sin((a+b)πx/2)=0  OR  cos((a-b)πx/2)=0

    Thus critical x's in [0,1]:
      x = 2k/(a+b), k=0..(a+b)/2
      x = (2k+1)/|a-b|, k=0..|a-b|/2-1

    We merge these two sorted rational lists without using Fractions for speed.

    Also, at these points, H can be computed with a single cosine:
      if x = 2k/(a+b):
          cos(bπx) = cos(aπx)  =>  H = 1/2 - 1/2 cos(2aπk/(a+b))
      if x = (2k+1)/|a-b|:
          cos(bπx) = -cos(aπx) =>  H = 1/2 - (|a-b|/(2(a+b))) cos(aπ(2k+1)/|a-b|)
    """
    if a <= 0 or b <= 0 or (a & 1) == 0 or (b & 1) == 0:
        raise ValueError("a,b must be positive odd integers")
    if a == b:
        raise ValueError("a != b required")
    s = a + b
    d = abs(a - b)
    if s % 2 != 0 or d % 2 != 0:
        raise ValueError("For odd a,b, a+b and |a-b| must be even")

    # Sequence A: x = 2k/s, k=0..s/2  (includes 0 and 1)
    # Store as (num, den, kind, k)
    a_len = s // 2 + 1

    # Sequence B: x = (2k+1)/d, k=0..d/2-1 (all strictly inside (0,1))
    b_len = d // 2

    i = 0
    j = 0
    out_z: list[float] = []
    prev_num = None
    prev_den = None

    while i < a_len or j < b_len:
        if j == b_len:
            num, den, kind, k = 2 * i, s, 0, i  # kind 0 = "sin-family"
            i += 1
        elif i == a_len:
            num, den, kind, k = 2 * j + 1, d, 1, j  # kind 1 = "cos-family"
            j += 1
        else:
            n1, d1 = 2 * i, s
            n2, d2 = 2 * j + 1, d
            left = n1 * d2
            right = n2 * d1
            if left < right:
                num, den, kind, k = n1, d1, 0, i
                i += 1
            elif left > right:
                num, den, kind, k = n2, d2, 1, j
                j += 1
            else:
                # exact duplicate (rare), consume both
                num, den, kind, k = n1, d1, 0, i
                i += 1
                j += 1

        # de-dupe (shouldn't happen often)
        if prev_num is not None and prev_num * den == num * prev_den:
            continue
        prev_num, prev_den = num, den

        if kind == 0:
            # x=2k/(a+b)
            # H = 1/2 - 1/2 cos(2aπk/(a+b))
            z = 0.5 - 0.5 * math.cos((2.0 * math.pi * a * k) / s)
        else:
            # x=(2k+1)/|a-b|
            # H = 1/2 - (|a-b|/(2(a+b))) cos(aπ(2k+1)/|a-b|)
            z = 0.5 - (d / (2.0 * s)) * math.cos((math.pi * a * (2 * k + 1)) / d)

        out_z.append(z)

    return out_z


# ---------- Geometry on the critical grid ----------
def F(a: int, b: int, c: int, d: int) -> float:
    """
    Trace the unique path from (0,0,0) to (1,1,1) and return the total
    variation in height z along the path (sum of absolute up/down changes).

    We build the critical x-grid for H_{a,b} and critical y-grid for H_{c,d}.
    Between consecutive critical lines, H_{a,b} and H_{c,d} are monotone, so
    the intersection curve crosses each cell boundary in at most two points.
    We traverse cell-by-cell; each step adds |Δz| between consecutive boundary hits.
    """
    Zx = _critical_z_values(a, b)
    Zy = _critical_z_values(c, d)
    M = len(Zx) - 1  # x-cells
    N = len(Zy) - 1  # y-cells

    end_corner = ("corner", M, N)

    # Use a *tiny* epsilon: true interior equalities are extremely rare.
    eps = 1e-16

    def sgn(v: float) -> int:
        if v > eps:
            return 1
        if v < -eps:
            return -1
        return 0

    # segment endpoints in a cell (i,j), returned as two boundary points
    # boundary point encodings:
    #   ("x", ix, j)  means crossing on vertical line ix within y-interval j
    #   ("y", jy, i)  means crossing on horizontal line jy within x-interval i
    #   ("corner", ix, jy)
    def cell_segment(i: int, j: int):
        zxi = Zx[i]
        zxip = Zx[i + 1]
        zyj = Zy[j]
        zyjp = Zy[j + 1]

        d00 = zxi - zyj
        d10 = zxip - zyj
        d01 = zxi - zyjp
        d11 = zxip - zyjp

        s00 = sgn(d00)
        s10 = sgn(d10)
        s01 = sgn(d01)
        s11 = sgn(d11)

        p1 = None
        p2 = None

        def add(pt):
            nonlocal p1, p2
            if p1 is None:
                p1 = pt
                return
            if p1 == pt:
                return
            if p2 is None:
                p2 = pt
                return
            if p2 == pt:
                return
            raise RuntimeError(
                "Degenerate cell (too many boundary points); try tightening eps"
            )

        # left edge: (i,j)->(i,j+1)
        if s00 == 0:
            add(("corner", i, j))
        if s01 == 0:
            add(("corner", i, j + 1))
        if s00 != 0 and s01 != 0 and s00 != s01:
            add(("x", i, j))

        # right edge: (i+1,j)->(i+1,j+1)
        if s10 == 0:
            add(("corner", i + 1, j))
        if s11 == 0:
            add(("corner", i + 1, j + 1))
        if s10 != 0 and s11 != 0 and s10 != s11:
            add(("x", i + 1, j))

        # bottom edge: (i,j)->(i+1,j)
        if s00 == 0:
            add(("corner", i, j))
        if s10 == 0:
            add(("corner", i + 1, j))
        if s00 != 0 and s10 != 0 and s00 != s10:
            add(("y", j, i))

        # top edge: (i,j+1)->(i+1,j+1)
        if s01 == 0:
            add(("corner", i, j + 1))
        if s11 == 0:
            add(("corner", i + 1, j + 1))
        if s01 != 0 and s11 != 0 and s01 != s11:
            add(("y", j + 1, i))

        if p1 is None:
            return None
        if p2 is None:
            raise RuntimeError("Degenerate cell (only one boundary point)")
        return (p1, p2)

    def z_of(pt) -> float:
        t = pt[0]
        if t == "x":
            return Zx[pt[1]]
        if t == "y":
            return Zy[pt[1]]
        # corner
        return 0.5 * (Zx[pt[1]] + Zy[pt[2]])

    def next_cell_across_edge(cur_cell, boundary_pt):
        i, j = cur_cell
        if boundary_pt[0] == "x":
            ix, jy = boundary_pt[1], boundary_pt[2]
            # adjacent cells: (ix-1,jy) and (ix,jy)
            return (ix, jy) if cur_cell == (ix - 1, jy) else (ix - 1, jy)
        else:
            jy, ix = boundary_pt[1], boundary_pt[2]
            # adjacent cells: (ix,jy-1) and (ix,jy)
            return (ix, jy) if cur_cell == (ix, jy - 1) else (ix, jy - 1)

    def choose_next_cell_at_corner(corner, from_cell, prev_pt):
        ix, jy = corner[1], corner[2]
        for di in (-1, 0):
            for dj in (-1, 0):
                ci, cj = ix + di, jy + dj
                if 0 <= ci < M and 0 <= cj < N and (ci, cj) != from_cell:
                    seg = cell_segment(ci, cj)
                    if seg is None or corner not in seg:
                        continue
                    other = seg[0] if seg[1] == corner else seg[1]
                    if other == prev_pt:
                        continue
                    return (ci, cj)
        # Only possible at the very end (or numerical corner-misclassification).
        return from_cell

    # Traverse
    cell = (0, 0)
    pt = ("corner", 0, 0)
    prev_pt = None
    total = 0.0

    # Safe bound; in practice the path is far smaller than M*N.
    max_steps = 4 * M * N + 10

    for _ in range(max_steps):
        if pt == end_corner:
            return total

        seg = cell_segment(cell[0], cell[1])
        if seg is None:
            raise RuntimeError("Lost the curve (no segment in expected cell)")

        if pt == seg[0]:
            nxt = seg[1]
        elif pt == seg[1]:
            nxt = seg[0]
        else:
            # Relocate if pt is a corner shared with a different incident cell
            if pt[0] != "corner":
                raise RuntimeError("Lost the curve (pt not on segment)")
            ix, jy = pt[1], pt[2]
            found = None
            for di in (-1, 0):
                for dj in (-1, 0):
                    ci, cj = ix + di, jy + dj
                    if 0 <= ci < M and 0 <= cj < N:
                        seg2 = cell_segment(ci, cj)
                        if seg2 is None or pt not in seg2:
                            continue
                        other = seg2[0] if seg2[1] == pt else seg2[1]
                        if prev_pt is not None and other == prev_pt:
                            continue
                        found = (ci, cj, other)
                        break
                if found:
                    break
            if not found:
                raise RuntimeError("Corner relocation failed")
            cell = (found[0], found[1])
            nxt = found[2]

        total += abs(z_of(nxt) - z_of(pt))

        # advance cell
        if nxt[0] == "corner":
            cell = choose_next_cell_at_corner(nxt, cell, pt)
        else:
            cell = next_cell_across_edge(cell, nxt)

        prev_pt, pt = pt, nxt

    raise RuntimeError("Exceeded max_steps (unexpected; try a smaller eps)")


def G(m: int, n: int) -> float:
    ps = [p for p in primes_up_to(n) if p >= m]
    total = 0.0
    for i, p in enumerate(ps):
        for q in ps[i + 1 :]:
            total += F(p, q, p, 2 * q - p)
    return total


# ---------- Statement checks ----------
# Given:
# F(3,5,3,7) ≈ 7.01772
# F(7,17,9,19) ≈ 26.79578
# G(3,20) ≈ 463.80866
assert abs(F(3, 5, 3, 7) - 7.01772) < 1e-5
assert abs(F(7, 17, 9, 19) - 26.79578) < 1e-5
assert abs(G(3, 20) - 463.80866) < 1e-5


if __name__ == "__main__":
    ans = G(500, 1000)
    print(f"{ans:.5f}")
