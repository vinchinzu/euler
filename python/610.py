"""Project Euler Problem 610: Roman Numerals II.

Find the expected value of a Roman Numeral generated by a random string where
each letter is generated with probability R%, the string ends with probability
(100-7R)%, and any letter that would result in an invalid Roman Numeral string
is discarded.

First we compute the expected value (E_0) of a Roman Numeral without any 'M's.
Since the length of Roman Numerals are bounded, we can easily compute the
expected value given a particular string prefix by trying to append all
characters and checking which ones result in valid Roman Numeral strings.

Finally, the expected value E of a Roman Numeral that may include 'M's is equal
to R(1000+E) + (1-R)(E_0); solving gives E = 1000R / (1-R) + (E_0).
"""

from __future__ import annotations

from functools import lru_cache


def to_roman(n: int) -> str:
    """Convert integer to Roman numeral."""
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syb = [
        "M", "CM", "D", "CD",
        "C", "XC", "L", "XL",
        "X", "IX", "V", "IV",
        "I"
    ]
    roman_num = ""
    i = 0
    while n > 0:
        for _ in range(n // val[i]):
            roman_num += syb[i]
            n -= val[i]
        i += 1
    return roman_num


def get_roman_letters() -> list[str]:
    """Get valid Roman numeral letters."""
    return ["I", "V", "X", "L", "C", "D", "M"]


def solve() -> float:
    """Solve Problem 610."""
    R = 0.14
    RE = 1 - len(get_roman_letters()) * R

    # Build Roman numeral map
    roman_numerals = {}
    for i in range(1000):
        roman_numerals[to_roman(i)] = i

    cache = {}

    def get_expected(letters: str) -> float:
        """Compute expected value recursively."""
        if letters in cache:
            return cache[letters]

        sum_prob = RE
        expected = RE * roman_numerals.get(letters, 0)

        for letter in get_roman_letters():
            new_letters = letters + letter
            if new_letters in roman_numerals:
                sum_prob += R
                expected += R * get_expected(new_letters)

        result = expected / sum_prob if sum_prob > 0 else 0
        cache[letters] = result
        return result

    ans = 1000 * R / (1 - R) + get_expected("")
    return ans


def main() -> float:
    """Main entry point."""
    result = solve()
    print(f"{result:.8f}")
    return result


if __name__ == "__main__":
    main()
